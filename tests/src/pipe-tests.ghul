namespace Tests is

    use Collections;
    use NSubstitute;

    use NSubstitute.SubstituteExtensions.returns;
    use NSubstitute.SubstituteExtensions.received;

    use Microsoft.VisualStudio.TestTools.UnitTesting;

    use Ghul.Pipes;

    class PipeShould is
        @test()

        _is_log_cleared: bool static;

        init() is
            if !_is_log_cleared then
                IO.File.create("/tmp/ghul-pipes.txt").close();
                _is_log_cleared = true;
            fi

            debug("AdaptorPipeShould.init()");
        si

        Pipe_SkipThenFirst_ReturnsCorrectElement() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            Assert.are_equal(new MAYBE[int](6), pipe.skip(5).first());
        si

        Pipe_TakeThenFirst_ReturnsFirstElement() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            Assert.are_equal(new MAYBE[int](1), pipe.take(5).first());
        si

        Pipe_FirstEmptySequence_ReturnsMaybeNot() is
            @test()

            let pipe = Pipe`[int].from(empty`[int]());

            let first = pipe.first();
            let expected = new MAYBE[int]();

            Assert.are_equal(expected, first);
        si

        Pipe_FindEmptySequence_ReturnsMaybeNot() is
            @test()

            let pipe = Pipe`[int].from(empty`[int]());

            let found = pipe.find(i => i > 10);
            let expected = new MAYBE[int]();

            Assert.are_equal(expected, found);
        si

        Pipe_FindNonEmptySequenceButNoMatch_ReturnsMaybeNot() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9]);

            let found = pipe.find(i => i == 10);
            let expected = new MAYBE[int]();

            Assert.are_equal(expected, found);
        si

        Pipe_FindSingleMatchingElement_ReturnsThatElement() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9]);

            let found = pipe.find(i => i == 4);
            let expected = new MAYBE[int](4);

            Assert.are_equal(expected, found);
        si

        Pipe_FindMultipleMatchingElement_ReturnsFirstMatchingElement() is
            @test()

            let array = [new THING(1), new THING(2), new THING(3), new THING(4), new THING(3), new THING(2), new THING(3), new THING(8), new THING(9)];

            let pipe = Pipe`[THING].from(array);

            let found = pipe.find(t => t.key == 3);
            let expected = new MAYBE[THING](array[2]);

            Assert.are_equal(expected, found);
        si

        Pipe_HasNoElements_ReturnsFalse() is
            @test()

            let pipe = Pipe`[int].from(empty`[int]());

            Assert.is_false(pipe.has(i => i == 4));
        si

        Pipe_HasSomeElementsButNoneMatch_ReturnsFalse() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9]);

            Assert.is_false(pipe.has(i => i == 99));
        si

        Pipe_HasSomeElementsOneMatches_ReturnsTrue() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9]);

            Assert.is_true(pipe.has(i => i == 4));
        si

        Pipe_HasSomeElementsMultipleMatches_ReturnsTrue() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9]);

            Assert.is_true(pipe.has(i => i > 4));
        si

        Pipe_SkipThenFilter_ReturnsFilteredTailSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.skip(5).filter(i => (i ∩ 1) == 0);

            assert_are_equal([6, 8, 10], result);
        si

        Pipe_FilterThenSkip_ReturnsFilteredTailSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.filter(i => (i ∩ 1) == 0).skip(1);

            assert_are_equal([4, 6, 8, 10], result);
        si

        Pipe_SkipThenIndex_StartsIndexingFromZero() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.skip(4).index();

            assert_are_equal([iv(0, 5), iv(1, 6), iv(2, 7), iv(3, 8), iv(4, 9), iv(5, 10)], result);
        si

        Pipe_IndexThenSkip_StartsIndexingFromCorrectOffset() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.index().skip(6);

            assert_are_equal([iv(6, 7), iv(7, 8), iv(8, 9), iv(9, 10)], result);
        si

        Pipe_TakeThenFilter_ReturnsFilteredHeadSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.take(5).filter(i => (i ∩ 1) == 0);

            assert_are_equal([2, 4], result);
        si

        Pipe_FilterThenTake_ReturnsFilteredHeadSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.filter(i => (i ∩ 1) == 0).take(3);

            assert_are_equal([2, 4, 6], result);
        si

        Pipe_IndexThenFilter_RetainsOriginalIndexes() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.index().filter(i => (i.value ∩ 1) == 1);

            assert_are_equal([iv(0,1), iv(2,3), iv(4,5), iv(6,7), iv(8,9)], result);
        si

        Pipe_FilterThenIndex_AppliesNewIndexes() is
            @test()

            let pipe = Pipe`[int].from([3, 4, 1, 5, 2, 3, 1, 4, 5]);

            let result = pipe.filter(i => i > 2).index();

            assert_are_equal([iv(0,3), iv(1,4), iv(2,5), iv(3,3), iv(4,4), iv(5,5)], result);
        si

        Pipe_SkipThenMap_ReturnsMappedTailSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.skip(5).map(i => "X" + i);

            assert_are_equal(["X6", "X7", "X8", "X9", "X10"], result);
        si

        Pipe_MapThenSkip_ReturnsMappedTailSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.map(i => "X" + i).skip(5);

            assert_are_equal(["X6", "X7", "X8", "X9", "X10"], result);
        si

        Pipe_TakeThenMap_ReturnsMappedHeadSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.take(4).map(i => "X" + i);

            assert_are_equal(["X1", "X2", "X3", "X4"], result);
        si

        Pipe_MapThenTake_ReturnsMappedHeadSequence() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.map(i => "X" + i).take(6);

            assert_are_equal(["X1", "X2", "X3", "X4", "X5", "X6"], result);
        si

        Pipe_TakeThenIndex_StartsIndexingFromZero() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.take(4).index();

            assert_are_equal([iv(0, 1), iv(1, 2), iv(2, 3), iv(3, 4)], result);
        si

        Pipe_IndexThenTake_StartsIndexingFromZero() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.index().take(6);

            assert_are_equal([iv(0, 1), iv(1, 2), iv(2, 3), iv(3, 4), iv(4, 5), iv(5, 6)], result);
        si

        Pipe_FilterThenFilter_ReturnsOnlyElementsThatMatchBothPredicates() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

            let result = pipe.filter(i => i > 3 /\ i < 9).filter(i => (i ∩ 1) == 0);

            assert_are_equal([4, 6, 8], result);
        si

        Pipe_MapThenMap_AppliesBothFunctionsToEveryElementInCorrectOrder() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6]);

            let result = pipe.map(i => "" + i + "-first").map(i => i + "-second");

            assert_are_equal(["1-first-second", "2-first-second", "3-first-second", "4-first-second", "5-first-second", "6-first-second"], result);
        si

        Pipe_Running() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6]);

            let result = pipe.reduce(0, (running, element) => running + element);

            Assert.are_equal(1 + 2 + 3 + 4 + 5 + 6, result);
        si

        Pipe_Mapped_Running() is
            @test()

            let pipe = Pipe`[int].from([1, 2, 3, 4, 5, 6]);

            let result = pipe.reduce(0, (running, element) => running + element, total => "total: " + total);

            Assert.are_equal("total: " + (1 + 2 + 3 + 4 + 5 + 6), result);
        si

        Sort_NoComparer_SortsInDefaultOrder() is
            @test()

            let pipe = Pipe`[int].from([2, 1, 4, 3, 6, 5]);

            let result = pipe.sort();

            assert_are_equal([1, 2, 3, 4, 5, 6], result);
        si

        Sort_GivenComparer_SortsInComparerOrder() is
            @test()

            let pipe = Pipe`[int].from([2, 1, 4, 3, 6, 5]);

            let result = pipe.sort(new ReverseIntComparer());

            assert_are_equal([6, 5, 4, 3, 2, 1], result);
        si

        Sort_GivenCompareFunction_SortsInCompareFunctionOrder() is
            @test()

            let pipe = Pipe`[int].from([2, 1, 4, 3, 6, 5]);

            let result = pipe.sort((x, y) => y - x);

            assert_are_equal([6, 5, 4, 3, 2, 1], result);
        si
    si

    class THING is
        key: int;

        init(key: int) is
            self.key = key;
        si
    si

    class ReverseIntComparer: IComparer`1[int] is
        init() is si
        compare(x: int, y: int) -> int => y - x;
    si
si


/*

These C# tests need to be translated into ghul
using Microsoft.VisualStudio.TestTools.UnitTesting;

using FluentAssertions;

using Pipes;

namespace Tests
{
    [TestClass]
    public class PipeShould
    {
    
        private static IndexedValue<int> ivs(int index, int value) => new IndexedValue<int>(index, value);
        [TestMethod]
        public void Pipe_SkipThenFirst_ReturnsCorrectElement()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Skip(5)
                .First()
                .Should()
                .Be(Maybe.From(6));
        }

        [TestMethod]
        public void Pipe_TakeThenFirst_ReturnsFirstElement()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Take(5)
                .First()
                .Should()
                .Be(Maybe.From(1));
        }

        [TestMethod]
        public void Pipe_FirstEmptySequence_ReturnsMaybeNot()
        {
            var pipe = Pipe.From(new int[0]);

            pipe
                .First()
                .Should()
                .Be(default(Maybe<int>));
        }

        [TestMethod]
        public void Pipe_FindEmptySequence_ReturnsMaybeNot()
        {
            var pipe = Pipe.From(new int[0]);

            pipe
                .Find(i => i > 10)
                .Should()
                .Be(default(Maybe<int>));
        }

        [TestMethod]
        public void Pipe_FindNonEmptySequenceButNoMatch_ReturnsMaybeNot()
        {
            var pipe = Pipe.From(new [] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });

            pipe
                .Find(i => i == 10)
                .Should()
                .Be(default(Maybe<int>));
        }

        [TestMethod]
        public void Pipe_FindSingleMatchingElement_ReturnsThatElement()
        {
            var pipe = Pipe.From(new [] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });

            pipe
                .Find(i => i == 4)
                .Should()
                .Be(Maybe.From(4));
        }

        private class Thing {
            public int Key;
            public Thing(int key) {
                Key = key;
            }
        }

        [TestMethod]
        public void Pipe_FindMultipleMatchingElement_ReturnsFirstMatchingElement()
        {
            var array = new [] { new Thing(1), new Thing(2), new Thing(3), new Thing(4), new Thing(3), new Thing(2), new Thing(3), new Thing(8), new Thing(9) };

            var pipe = Pipe.From(array);

            pipe
                .Find(t => t.Key == 3)
                .Should()
                .Be(Maybe.From(array[2]));
        }

        [TestMethod]
        public void Pipe_HasNoElements_ReturnsFalse() {
            var pipe = Pipe.From(new int[0]);

            pipe
                .Has(i => i == 4)
                .Should()
                .Be(false);

        }

        [TestMethod]
        public void Pipe_HasSomeElementsButNoneMatch_ReturnsFalse() {
            var pipe = Pipe.From(new [] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });

            pipe
                .Has(i => i == 99)
                .Should()
                .Be(false);

        }

        [TestMethod]
        public void Pipe_HasSomeElementsOneMatches_ReturnsTrue() {
            var pipe = Pipe.From(new [] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });

            pipe
                .Has(i => i == 4)
                .Should()
                .Be(true);
        }

        [TestMethod]
        public void Pipe_HasSomeElementsMultipleMatches_ReturnsTrue() {
            var pipe = Pipe.From(new [] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });

            pipe
                .Has(i => i > 4)
                .Should()
                .Be(true);
        }

        [TestMethod]
        public void Pipe_SkipThenFilter_ReturnsFilteredTailSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Skip(5)
                .Filter(i => (i & 1) == 0)
                .Should()
                .Equal(new [] { 6, 8, 10 });
        }

        [TestMethod]
        public void Pipe_FilterThenSkip_ReturnsFilteredTailSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Filter(i => (i & 1) == 0)
                .Skip(1)
                .Should()
                .Equal(new [] { 4, 6, 8, 10 });
        }

        [TestMethod]
        public void Pipe_SkipThenIndex_StartsIndexingFromZero()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Skip(4)
                .Index()
                .Should()
                .Equal(new [] { ivs(0, 5), ivs(1, 6), ivs(2, 7), ivs(3, 8), ivs(4, 9), ivs(5, 10) });
        }

        [TestMethod]
        public void Pipe_IndexThenSkip_StartsIndexingFromCorrectOffset()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Index()
                .Skip(6)
                .Should()
                .Equal(new [] { ivs(6, 7), ivs(7, 8), ivs(8, 9), ivs(9, 10) });
        }

        [TestMethod]
        public void Pipe_TakeThenFilter_ReturnsFilteredHeadSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Take(5)
                .Filter(i => (i & 1) == 0)
                .Should()
                .Equal(new [] { 2, 4 });
        }

        [TestMethod]
        public void Pipe_FilterThenTake_ReturnsFilteredHeadSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Filter(i => (i & 1) == 0)
                .Take(3)
                .Should()
                .Equal(new [] { 2, 4, 6 });
        }

        [TestMethod]
        public void Pipe_IndexThenFilter_RetainsOriginalIndexes()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Index()
                .Filter(i => (i.Value & 1) == 1)
                .Should()
                .Equal(new [] { ivs(0,1), ivs(2,3), ivs(4,5), ivs(6,7), ivs(8,9) });
        }

        [TestMethod]
        public void Pipe_FilterThenIndex_AppliesNewIndexes()
        {
            var pipe = Pipe.From(new [] {3, 4, 1, 5, 2, 3, 1, 4, 5});

            pipe
                .Filter(i => i > 2)
                .Index()
                .Should()
                .Equal(new [] { ivs(0,3), ivs(1,4), ivs(2,5), ivs(3,3), ivs(4,4), ivs(5,5) });
        }

        [TestMethod]
        public void Pipe_SkipThenMap_ReturnsMappedTailSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Skip(5)
                .Map(i => "X" + i)
                .Should()
                .Equal(new [] { "X6", "X7", "X8", "X9", "X10" });
        }

        [TestMethod]
        public void Pipe_MapThenSkip_ReturnsMappedTailSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Map(i => "X" + i)
                .Skip(5)
                .Should()
                .Equal(new [] { "X6", "X7", "X8", "X9", "X10" });
        }

        [TestMethod]
        public void Pipe_TakeThenMap_ReturnsMappedHeadSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Take(4)
                .Map(i => "X" + i)
                .Should()
                .Equal(new [] { "X1", "X2", "X3", "X4" });
        }

        [TestMethod]
        public void Pipe_MapThenTake_ReturnsMappedHeadSequence()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Map(i => "X" + i)
                .Take(6)
                .Should()
                .Equal(new [] { "X1", "X2", "X3", "X4", "X5", "X6" });
        }

        [TestMethod]
        public void Pipe_TakeThenIndex_StartsIndexingFromZero()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Take(4)
                .Index()
                .Should()
                .Equal(new [] { ivs(0, 1), ivs(1, 2), ivs(2, 3), ivs(3, 4) });
        }

        [TestMethod]
        public void Pipe_IndexThenTake_StartsIndexingFromZero()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Index()
                .Take(6)
                .Should()
                .Equal(new [] { ivs(0, 1), ivs(1, 2), ivs(2, 3), ivs(3, 4), ivs(4, 5), ivs(5, 6) });
        }

        [TestMethod]
        public void Pipe_FilterThenFilter_ReturnsOnlyElementsThatMatchBothPredicates()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});

            pipe
                .Filter(i => i > 3 && i < 9)
                .Filter(i => (i & 1) == 0)
                .Should()
                .Equal(new [] { 4, 6, 8 });
        }

        [TestMethod]
        public void Pipe_MapThenMap_AppliesBothFunctionsToEveryElementInCorrectOrder()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6});

            pipe
                .Map(i => i + "-first")
                .Map(i => i + "-second")
                .Should()
                .Equal(new [] { "1-first-second", "2-first-second", "3-first-second", "4-first-second", "5-first-second", "6-first-second" });
        }

        [TestMethod]
        public void Pipe_Running()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6});

            pipe
                .Reduce(0, (running, element) => running + element)
                .Should()
                .Be(1 + 2 + 3 + 4 + 5 + 6);
        }

        [TestMethod]
        public void Pipe_Mapped_Running()
        {
            var pipe = Pipe.From(new [] {1, 2, 3, 4, 5, 6});

            pipe
                .Reduce(0, (running, element) => running + element, total => "total: " + total)
                .Should()
                .Be("total: " + (1 + 2 + 3 + 4 + 5 + 6));
        }

        [TestMethod]
        public void Sort_NoComparer_SortsInDefaultOrder()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            pipe
                .Sort()
                .Should()
                .Equal(new [] { 1, 2, 3, 4, 5, 6 });
        }

        [TestMethod]
        public void Sort_GivenComparer_SortsInComparerOrder()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            pipe
                .Sort(new ReverseIntComparer())
                .Should()
                .Equal(new [] { 6, 5, 4, 3, 2, 1 });
        }

        [TestMethod]
        public void Sort_GivenCompareFunction_SortsInCompareFunctionOrder()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            pipe
                .Sort((int x, int y) => y - x)
                .Should()
                .Equal(new [] { 6, 5, 4, 3, 2, 1 });
        }

        [TestMethod]
        public void Sort_CalledTwice_SortsInLastComparerOrder()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            pipe
                .Sort()
                .Sort(new ReverseIntComparer())
                .Should()
                .Equal(new [] { 6, 5, 4, 3, 2, 1 });
        }

        [TestMethod]
        public void Sort_EnumeratedTwice_ReturnsSameResultBothTimes()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            var sorted = 
                pipe
                    .Sort(new ReverseIntComparer());

            sorted.Collect();

            sorted
                .Should()
                .Equal(new [] { 6, 5, 4, 3, 2, 1 });            
        }

        [TestMethod]
        public void ToString_WithNoSeparatorArgument_ReturnsStringRepresentationOfAllElementsSeparatedWithACommaAndSpace()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            pipe
                .ToString()
                .Should()
                .Be("2, 1, 4, 3, 6, 5");
        }

        [TestMethod]
        public void ToString_WithSeparatorArgument_ReturnsStringRepresentationOfAllElementsSeparatedWithThatSeparator()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            pipe
                .ToString("///")
                .Should()
                .Be("2///1///4///3///6///5");
        }

        [TestMethod]
        public void ToString_CalledTwice_ReturnsStringRepresentationOfAllElements()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            pipe
                .ToString();

            pipe
                .ToString("\t")
                .Should()
                .Be("2\t1\t4\t3\t6\t5");
        }

                [TestMethod]
        public void AppendTo_WithNoSeparatorArgument_AppendsStringRepresentationOfAllElementsSeparatedWithACommaAndSpace()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            var result = new System.Text.StringBuilder("XX");

            pipe
                .AppendTo(result);

            result
                .ToString()
                .Should()
                .Be("XX2, 1, 4, 3, 6, 5");
        }

        [TestMethod]
        public void AppendTo_WithSeparatorArgument_AppendsStringRepresentationOfAllElementsSeparatedWithThatSeparator()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            var result = new System.Text.StringBuilder("XX");

            pipe
                .AppendTo(result, "///");

            result
                .ToString()
                .Should()
                .Be("XX2///1///4///3///6///5");
        }

        [TestMethod]
        public void AppendTo_CalledTwice_AppendsStringRepresentationOfAllElementsTwice()
        {
            var pipe = Pipe.From(new [] {2, 1, 4, 3, 6, 5});

            var result = new System.Text.StringBuilder("XX");

            pipe
                .AppendTo(result, "-");

            result.Append("YY");

            pipe
                .AppendTo(result, "_");

            result
                .ToString()
                .Should()
                .Be("XX2-1-4-3-6-5YY2_1_4_3_6_5");
        }


        class ReverseIntComparer: System.Collections.Generic.IComparer<int>
        {
            public int Compare(int x, int y)
            {
                return y - x;
            }
        }
    }
}


*/


        /* these are example tests in ghul


        Map_EmptyArray_ReturnsEmptySequence() is
            @test()

            let pipe = 
                Ghul.Pipes.Pipe`[int]
                    .from(empty`[int]());

            let result = 
                pipe
                    .map(i => i.to_string());

            assert_are_equal(empty`[string](), result);
        si

        Map_IntsToStrings_ReturnsExpectedSequence() is
            @test()

            let pipe = 
                Ghul.Pipes.Pipe`[int]
                    .from([3, 4, 1, 5, 2, 3, 1, 4, 5]);

            let result = 
                pipe
                    .map(i => i.to_string());

            assert_are_equal(["3", "4", "1", "5", "2", "3", "1", "4", "5"], result);
        si

        Map_CalledTwice_AppliesBothFunctionsToEveryElementInCorrectOrder() is
            @test()

            let pipe = 
                Ghul.Pipes.Pipe`[int]
                    .from([1, 2, 3, 4, 5, 6]);

            let result = 
                pipe
                    .map(i => "" + i + "-first")
                    .map(i => i + "-second");

            assert_are_equal(["1-first-second", "2-first-second", "3-first-second", "4-first-second", "5-first-second", "6-first-second"], result);
        si

        Index_EmptyArray_ReturnsEmptySequence() is
            @test()

            let pipe = 
                Ghul.Pipes.Pipe`[int]
                    .from(empty`[int]());

            let result = 
                pipe
                    .index();

            assert_are_equal(empty`[INDEXED_VALUE[int]](), result);
        si

        Index_MultipleElements_ReturnsExpectedSequence() is
            @test()

            let pipe = 
                Ghul.Pipes.Pipe`[string]
                    .from(["3", "4", "1", "5", "2", "3", "1", "4", "5"]);

            let result = 
                pipe
                    .index();

            assert_are_equal([ivs(0, "3"), ivs(1, "4"), ivs(2, "1"), ivs(3, "5"), ivs(4, "2"), ivs(5, "3"), ivs(6, "1"), ivs(7, "4"), ivs(8, "5")], result);
        si

        Index_MultipleElementsPositiveInitialIndex_ReturnsExpectedSequence() is
            @test()

            let pipe = 
                Ghul.Pipes.Pipe`[string]
                    .from(["3", "4", "1", "5", "2", "3", "1", "4", "5"]);

            let result = 
                pipe
                    .index(3);

            assert_are_equal([ivs(3, "3"), ivs(4, "4"), ivs(5, "1"), ivs(6, "5"), ivs(7, "2"), ivs(8, "3"), ivs(9, "1"), ivs(10, "4"), ivs(11, "5")], result);
        si

        Index_MultipleElementsNegativeInitialIndex_ReturnsExpectedSequence() is
            @test()

            let pipe = 
                Ghul.Pipes.Pipe`[string]
                    .from(["3", "4", "1", "5", "2", "3", "1", "4", "5"]);

            let result = 
                pipe
                    .index(-3);

            assert_are_equal([ivs(-3, "3"), ivs(-2, "4"), ivs(-1, "1"), ivs(0, "5"), ivs(1, "2"), ivs(2, "3"), ivs(3, "1"), ivs(4, "4"), ivs(5, "5")], result);
        si

        IndexedValue_ToString_ReturnsIndexAndValueInParentheses() is
            @test()

            let indexedValue = ivs(1234, "ABCD");

            Assert.are_equal("(1234,ABCD)", indexedValue.to_string());
        si        
    si
    */
